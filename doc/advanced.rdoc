
== Advanced Rantfiles

=== Sharing variables

The +var+ command allows you to share variables between Rantfiles and
to set variables from the commandline. Just use +var+ like a hash to
set/get variables:
    var[:manifest] = %w(README Rantfile myprog.rb lib)
In this example, :manifest is the variable name, which has to be a
string or symbol. Symbols as variable names are converted to strings.
Now you can access the "manifest" variable in every Rantfile of your
project:
    file "MANIFEST" do |t|
	open(t.name, "w") { |f|
	    var[:manifest].each { |str| f.puts(str) }
	}
    end

Arguments of the form VAR=VAL to the rant command are also available
through +var+:
    % cat Rantfile
    task :show_test do
	puts var[:test]
    end
    % rant
    nil
    % rant test=hello
    hello

For some variables it is necessary to make them available for
subprocesses, like CC or CFLAGS:
    var.env %w(CC CFLAGS)
The variables CC and CFLAGS are available through +var+ as always and
are mapped to environment variables.

=== The "ignore" variable

The "ignore" variable is a list of files/regular expressions which are
ignored when selecting files with the +sys+ command:
    var[:ignore] = ["CVS", /~$/]
If you select files with <tt>sys[]</tt> now, the lists won't contain
any directory/file named "CVS" or ending in ~. Examples would be:
    CVS
    src/CVS
    src/CVS/xy
    xy~
    src/util.c~

=== More on selecting files with the glob operator

The sys[] operator actually returns a _filelist_ object, which behaves
similar to an array. There are many methods for filelist objects, here
is a brief overview:

    # create a filelist containing all files in the current directory
    # and in the src directory
    fl = sys["*", "src/*"]

    # remove all files from the list which end in .bak
    fl.exclude "*.bak"

    # add all .rb files in directories lib and test
    fl.include "lib/*.rb", "test/*.rb"

    # remove all files from the list which contain the path element
    # "coverage" (e.g.: test/coverage/ lib/coverage/main.c)
    fl.exclude_all "coverage"

    # add a single file to the list
    fl << "doc/README"

    # get a new filelist containing only directories, fl isn't
    # modified:
    dirs = fl.select { |f| File.directory? f }

    # create a manifest file
    open("MANIFEST", "w") { |f| f.puts fl }

Additionally, you can use all methods available for an array. Lookup
docs with ri for array methods:
    % ri Array

=== Cleaning up generated files

Use the +Clean+ generator in your Rantfiles:
    import "clean"

    file "junk" do
       # create junk
    end

    # create a task called clean
    desc "cleanup generated files"
    gen Clean

    # var[:clean] is a filelist object now
    var[:clean] << "junk"
    var[:clean].include "**/*.bak", "**/*.obj"

=== Let Rant cleanup for you

Use the +AutoClean+ generator which will remove all files generated by
any filetask (include those created by rules):
    import "autoclean"

    file "junk" do
        # create junk
    end

    gen Rule, :o => :c do |t|
        sys "cc -c -o #{t.name} #{t.source}"
    end

    desc "Cleanup generated files."
    gen AutoClean, :clean
    # The clean task automatically detects which files where created
    # by our rule and the junk task.
    # Additionally we can add files to remove to the variable with the
    # same name as the AutoClean taskname (here: clean):
    var[:clean].include "**/*.bak"

TAKE CARE:: As of version 0.3.6 of Rant, AutoClean will recursively
            remove directories for which a task exists. Meaning:
               gen Directory, "doc/html"
            AutoClean will recursively remove the doc directory!
This will probably change in the next release.

=== The DirectedRule generator

A directed rule is some sort of special rule. It searches for source
files in one or more given directories and produces file in one output
directory.

    import "directedrule"

    ro = gen DirectedRule, "obj" => sys["src_*"], :o => :c do |t|
	sys "cc -c -o #{t.name} #{t.source}"
    end

This rule produces a file task for targets in the obj/ directory
ending in `.o'. It looks for a source file in all directories starting
with `src_' and files ending in `.c'.

Practically, this means that it compiles the C files in src_x/, src_y,
... to object files which are placed in the obj/ directory.

Look in the doc/examples/directedrule directory of the Rant
distribution for a small example project.

=== Constraining variables

Rant allows you to constrain variables which are managed by the +var+
command (and thus can be set from the commandline):

    var :count, 0..10

This initializes the variable +count+ to 0 and restricts it to the
integer range 0 to 10. Create a task to test it:

    task :show_count do
        puts var[:count]
    end

And now try to set the count variable from the commandline:

    % rant
    0
    % rant count=5
    5
    % rant count=-1
    rant: [ERROR] in file `/home/stefan/tmp/Rantfile', line 2:
		  "-1" doesn't match constraint: integer 0..10
    rant aborted!
    % rant count=100
    rant: [ERROR] in file `/home/stefan/tmp/Rantfile', line 2:
		  "100" doesn't match constraint: integer 0..10
    rant aborted!

Other available constraints:

    # variable str is ensured to be a string
    var :str, :String

    # variable b is a bool (always true or false)
    # can be set to "yes", "no", "1", "0", "true", "false"
    var :b, :Bool

=== The Action generator

Consider a C project. In some C source file, let's say config.h you
define the project version, e.g.:
    #define VERSION 2.3
Many of your tools use this version number, so you have decided to
duplicate it in a file called +version+, which contains just a line
with the program version. On solution to automate the +version+ file
creation would be to write a file task:
    file "version" => "config.h" do |t|
	puts "updating version file"
	open("w", t.name) { |f| f.puts(extract_config_version()) }
    end
and make all other tasks that need this version dependent on it. But
this can get very tedious if you have many tasks that need this
version file. Another solution is to just run the task every time the
Rantfile is sourced. This can be achieved by placing the following
statement after the "version" task:
    rac.build "version"
This tells rant to immediately invoke all tasks that are required to
build the version file. But imagine your users just want to see the
list of available tasks:
    % rant --tasks
    updating version file
    rant foo		# build foo program
    rant lib		# build libfoo.so
    rant clean		# remove generated files
Hmm, we really didn't need the version to show our users the available
tasks. To avoid this, wrap such code in an Action:
    file "version" => "config.h" do |t|
	puts "updating version file"
	open("w", t.name) { |f| f.puts(extract_config_version()) }
    end

    gen Action do
	rac.build "version"
    end
And now on a clean source base:
    % rant --tasks
    rant foo		# build foo program
    rant lib		# build libfoo.so
    rant clean		# remove generated files
OK. Didn't confuse our users! Run any task:
    % rant foo
    updating version file
    cc -o foo foo.c
This means, Action blocks are executed whenever we actually want to
build something, not just extract information from our Rantfile. It is
recommended to wrap any code that has effects on the environment
(mainly the file system) inside an Action block instead of embedding
it plain in the Rantfile.

An Action block also won't be run when our Rantfile is read by
rant-import.

== See also

Rantfile basics::
    doc/rantfile.rdoc[link:files/doc/rantfile_rdoc.html]
Rant Overview::
    README[link:files/README.html]
